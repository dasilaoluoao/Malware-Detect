# -*- coding: utf-8 -*-

###########################################################################
## Python code generated with wxFormBuilder (version Jun 17 2015)
## http://www.wxformbuilder.org/
##
## PLEASE DO "NOT" EDIT THIS FILE!
###########################################################################
import glob
import math
import os
import re
import time

import cv2
import pefile
import tensorflow as tf
import numpy as np
import wx
import wx.xrc
from PIL import Image


###########################################################################
## Class Login
###########################################################################


class Login(wx.Frame):

    def __init__(self, parent):
        wx.Frame.__init__(self, parent, id=wx.ID_ANY, title=u"登录界面", pos=wx.DefaultPosition, size=wx.Size(500, 300),
                          style=wx.DEFAULT_FRAME_STYLE | wx.TAB_TRAVERSAL)

        self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)

        bSizer3 = wx.BoxSizer(wx.VERTICAL)

        bSizer3.AddSpacer(10)

        self.sys_name = wx.StaticText(self, wx.ID_ANY, u"恶 意 代 码 检 测 系 统", wx.DefaultPosition, wx.DefaultSize, 0)
        self.sys_name.Wrap(-1)
        self.sys_name.SetFont(wx.Font(20, 70, 90, 90, False, wx.EmptyString))

        bSizer3.Add(self.sys_name, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL, 5)

        gSizer2 = wx.GridSizer(0, 2, 0, 0)

        self.m_staticText8 = wx.StaticText(self, wx.ID_ANY, u"用户名", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticText8.Wrap(-1)
        self.m_staticText8.SetFont(wx.Font(14, 70, 90, 90, False, wx.EmptyString))

        gSizer2.Add(self.m_staticText8, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)

        self.username = wx.TextCtrl(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.Size(150, -1), 0)
        self.username.SetMaxLength(6)
        gSizer2.Add(self.username, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)

        self.m_staticText9 = wx.StaticText(self, wx.ID_ANY, u"密  码", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticText9.Wrap(-1)
        self.m_staticText9.SetFont(wx.Font(14, 70, 90, 90, False, wx.EmptyString))

        gSizer2.Add(self.m_staticText9, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL, 5)

        self.password = wx.TextCtrl(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.Size(150, -1),
                                    wx.TE_PASSWORD)
        self.password.SetMaxLength(6)
        gSizer2.Add(self.password, 0, wx.ALL, 5)

        bSizer3.Add(gSizer2, 1, wx.EXPAND, 5)

        ok_cancel_help = wx.StdDialogButtonSizer()
        self.ok_cancel_helpOK = wx.Button(self, wx.ID_OK)
        ok_cancel_help.AddButton(self.ok_cancel_helpOK)
        self.ok_cancel_helpCancel = wx.Button(self, wx.ID_CANCEL)
        ok_cancel_help.AddButton(self.ok_cancel_helpCancel)
        self.ok_cancel_helpHelp = wx.Button(self, wx.ID_HELP)
        ok_cancel_help.AddButton(self.ok_cancel_helpHelp)
        ok_cancel_help.Realize();

        bSizer3.Add(ok_cancel_help, 0, wx.ALIGN_CENTER_HORIZONTAL, 5)

        self.register = wx.Button(self, wx.ID_ANY, u"注册", wx.DefaultPosition, wx.DefaultSize, 0)
        self.register.SetFont(wx.Font(wx.NORMAL_FONT.GetPointSize(), 70, 90, 90, False, wx.EmptyString))

        bSizer3.Add(self.register, 0, wx.ALL | wx.ALIGN_RIGHT, 5)

        self.SetSizer(bSizer3)
        self.Layout()

        self.Centre(wx.BOTH)

        # Connect Events
        self.ok_cancel_helpCancel.Bind(wx.EVT_BUTTON, self.cancel_event)
        self.ok_cancel_helpHelp.Bind(wx.EVT_BUTTON, self.help_event)
        self.ok_cancel_helpOK.Bind(wx.EVT_BUTTON, self.ok_event)
        self.register.Bind(wx.EVT_BUTTON, self.open_register_frame_event)

    def __del__(self):
        pass

    # Virtual event handlers, overide them in your derived class
    def cancel_event(self, event):
        self.Close()

    def help_event(self, event):
        wx.MessageBox("初始用户名和密码为admin和000000")

    def ok_event(self, event):
        username = self.username.GetValue()
        password = self.password.GetValue()
        if username == '' or password == '':
            wx.MessageBox("用户名或密码为空，请输入用户名和密码登录")
        else:
            f = open('login_info.txt', 'r')
            login_info = f.readlines()
            f.close()
            flag = 0
            for info in login_info:
                u_name = info.split(',')[0]
                pwd = info.split(',')[1][0:6]
                if u_name == username and pwd == password:
                    main_frame = Main(parent=None)
                    main_frame.Show()
                    self.Close()
                    flag = 1
                    break
            if flag == 0:
                wx.MessageBox("用户名或密码错误")

    def open_register_frame_event(self, event):
        register = Register(parent=None)
        register.Show()


###########################################################################
## Class Register
###########################################################################

class Register(wx.Frame):

    def __init__(self, parent):
        wx.Frame.__init__(self, parent, id=wx.ID_ANY, title=u"注册界面", pos=wx.DefaultPosition, size=wx.Size(500, 300),
                          style=wx.DEFAULT_FRAME_STYLE | wx.TAB_TRAVERSAL)

        self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)

        bSizer4 = wx.BoxSizer(wx.VERTICAL)

        bSizer4.AddSpacer(30)

        gSizer3 = wx.GridSizer(0, 2, 0, 0)

        self.m_staticText10 = wx.StaticText(self, wx.ID_ANY, u"用户名", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticText10.Wrap(-1)
        self.m_staticText10.SetFont(wx.Font(14, 70, 90, 90, False, wx.EmptyString))

        gSizer3.Add(self.m_staticText10, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_BOTTOM, 5)

        self.username = wx.TextCtrl(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.DefaultSize, 0)
        self.username.SetMaxLength(6)
        self.username.SetMinSize(wx.Size(150, -1))

        gSizer3.Add(self.username, 0, wx.ALL | wx.ALIGN_BOTTOM, 5)

        self.m_staticText11 = wx.StaticText(self, wx.ID_ANY, u"密  码", wx.DefaultPosition, wx.DefaultSize, 0)
        self.m_staticText11.Wrap(-1)
        self.m_staticText11.SetFont(wx.Font(14, 70, 90, 90, False, wx.EmptyString))

        gSizer3.Add(self.m_staticText11, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL | wx.ALIGN_CENTER_VERTICAL, 5)

        self.password = wx.TextCtrl(self, wx.ID_ANY, wx.EmptyString, wx.DefaultPosition, wx.Size(150, -1),
                                    wx.TE_PASSWORD)
        self.password.SetMaxLength(6)
        gSizer3.Add(self.password, 0, wx.ALL | wx.ALIGN_CENTER_VERTICAL, 5)

        bSizer4.Add(gSizer3, 1, wx.EXPAND, 5)

        bSizer4.AddSpacer(20)

        ok_cancel_help = wx.StdDialogButtonSizer()
        self.ok_cancel_helpOK = wx.Button(self, wx.ID_OK)
        ok_cancel_help.AddButton(self.ok_cancel_helpOK)
        self.ok_cancel_helpCancel = wx.Button(self, wx.ID_CANCEL)
        ok_cancel_help.AddButton(self.ok_cancel_helpCancel)
        self.ok_cancel_helpHelp = wx.Button(self, wx.ID_HELP)
        ok_cancel_help.AddButton(self.ok_cancel_helpHelp)
        ok_cancel_help.Realize()

        bSizer4.Add(ok_cancel_help, 0, wx.ALIGN_CENTER_HORIZONTAL, 5)

        bSizer4.AddSpacer(50)

        self.SetSizer(bSizer4)
        self.Layout()

        self.Centre(wx.BOTH)

        # Connect Events
        self.ok_cancel_helpCancel.Bind(wx.EVT_BUTTON, self.cancel_event)
        self.ok_cancel_helpHelp.Bind(wx.EVT_BUTTON, self.help_event)
        self.ok_cancel_helpOK.Bind(wx.EVT_BUTTON, self.ok_event)

    def __del__(self):
        pass

    # Virtual event handlers, overide them in your derived class
    def cancel_event(self, event):
        self.Close()

    def help_event(self, event):
        wx.MessageBox("用户名和密码仅支持字母和数字，用户名长度不超过6位，密码长度为6位")

    def ok_event(self, event):
        u_name = self.username.GetValue()
        pwd = self.password.GetValue()
        if re.match('\w', u_name) != None and re.match('\w', pwd) != None:
            if len(pwd) < 6:
                wx.MessageBox("密码必须6位，请重新输入")
            else:
                f = open('login_info.txt', 'a')
                f.write('\n' + u_name + ',' + pwd)
                f.close()
                wx.MessageBox("注册成功")
                self.Close()
        else:
            wx.MessageBox("用户名或密码不规范")


###########################################################################
## Class Main
###########################################################################


class Main(wx.Frame):

    def __init__(self, parent):
        wx.Frame.__init__(self, parent, id=wx.ID_ANY, title=u"检测界面", pos=wx.DefaultPosition,
                          size=wx.Size(500, 300), style=wx.DEFAULT_FRAME_STYLE | wx.TAB_TRAVERSAL)

        self.SetSizeHintsSz(wx.DefaultSize, wx.DefaultSize)

        bSizer1 = wx.BoxSizer(wx.VERTICAL)

        self.select_train = wx.DirPickerCtrl(self, wx.ID_ANY, u"选择训练数据", u"Select a folder", wx.DefaultPosition,
                                             wx.DefaultSize, wx.DIRP_DEFAULT_STYLE)
        bSizer1.Add(self.select_train, 0, wx.ALL | wx.EXPAND, 5)

        self.select_test = wx.DirPickerCtrl(self, wx.ID_ANY, u"选择测试数据", u"Select a folder", wx.DefaultPosition,
                                            wx.DefaultSize, wx.DIRP_DEFAULT_STYLE)
        bSizer1.Add(self.select_test, 0, wx.ALL | wx.EXPAND, 5)

        gSizer1 = wx.GridSizer(0, 2, 0, 0)

        self.cnn_start = wx.Button(self, wx.ID_ANY, u"训练模型", wx.DefaultPosition, wx.DefaultSize, 0)
        gSizer1.Add(self.cnn_start, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL, 5)

        self.detect_code = wx.Button(self, wx.ID_ANY, u"检测恶意代码", wx.DefaultPosition, wx.DefaultSize, 0)
        gSizer1.Add(self.detect_code, 0, wx.ALL | wx.ALIGN_CENTER_HORIZONTAL, 5)

        bSizer1.Add(gSizer1, 0, wx.EXPAND, 5)

        self.m_scrolledWindow2 = wx.ScrolledWindow(self, wx.ID_ANY, wx.DefaultPosition, wx.DefaultSize,
                                                   wx.HSCROLL | wx.VSCROLL)
        self.m_scrolledWindow2.SetScrollRate(5, 5)
        bSizer2 = wx.BoxSizer(wx.VERTICAL)

        self.detect_result = wx.TextCtrl(self.m_scrolledWindow2, wx.ID_ANY, u"暂无数据", wx.DefaultPosition, wx.DefaultSize,
                                         wx.TE_MULTILINE)
        bSizer2.Add(self.detect_result, 1, wx.ALL | wx.EXPAND, 5)

        self.m_scrolledWindow2.SetSizer(bSizer2)
        self.m_scrolledWindow2.Layout()
        bSizer2.Fit(self.m_scrolledWindow2)
        bSizer1.Add(self.m_scrolledWindow2, 1, wx.EXPAND | wx.ALL, 5)

        self.SetSizer(bSizer1)
        self.Layout()

        self.Centre(wx.BOTH)

        # Connect Events
        self.select_train.Bind(wx.EVT_DIRPICKER_CHANGED, self.get_train_dir)
        self.select_test.Bind(wx.EVT_DIRPICKER_CHANGED, self.get_test_dir)
        self.cnn_start.Bind(wx.EVT_BUTTON, self.CNN_start)
        self.detect_code.Bind(wx.EVT_BUTTON, self.detect_malicious_code)

        self.trainflag = 0
        self.testflag = 0
        self.traindir = None
        self.testdir = None

    def __del__(self):
        pass

    # Virtual event handlers, overide them in your derived class
    def get_train_dir(self, event):
        if self.select_train.GetPath() != '':
            self.trainflag = 1
            self.traindir = self.select_train.GetPath()

    def get_test_dir(self, event):
        if self.select_test.GetPath() != '':
            self.testflag = 1
            self.testdir = self.select_test.GetPath()

    def CNN_start(self, event):
        if self.trainflag == 0:
            wx.MessageBox('未选择训练数据文件夹')
        else:
            train_path = self.traindir
            if os.path.exists('E:/model.meta') != True:
                self.file2gray(train_path + "\\")
                self.CNN_train(train_path + "\\")
            self.trainflag = 2
            wx.MessageBox('模型训练完成')

    def detect_malicious_code(self, event):
        if self.testflag == 0:
            wx.MessageBox('未选择测试数据文件夹')
        else:
            if self.trainflag == 2:
                test_path = self.testdir
                # wx.MessageBox(test_path)
                result = self.CNN_predict(test_path + "\\")
                print(result)
                # self.detect_result.SetValue(result)
            else:
                wx.MessageBox('未完成模型训练')

    # self.detect_result.SetValue("1\n2\n3")

    def CNN_train(self, train_dir):
        data, label = self.read_img(train_dir)
        # 打乱顺序
        num_example = data.shape[0]
        arr = np.arange(num_example)
        np.random.shuffle(arr)
        data = data[arr]
        (dx, dy, dz) = data.shape
        data = data.reshape([dx, dy, dz, 1])
        label = label[arr]
        w = dy
        h = dz
        # 将所有数据分为训练集和验证集
        ratio = 0.8
        s = np.int(num_example * ratio)
        x_train = data[:s]
        y_train = label[:s]
        x_val = data[s:]
        y_val = label[s:]
        # -----------------构建网络----------------------
        # 占位符
        x = tf.placeholder(tf.float32, shape=[None, w, h, 1], name='x')
        y_ = tf.placeholder(tf.int32, shape=[None, ], name='y_')
        regularizer = tf.contrib.layers.l2_regularizer(0.0001)
        logits = self.inference(x, False, regularizer, w, h)
        # (小处理)将logits乘以1赋值给logits_eval，定义name，方便在后续调用模型时通过tensor名字调用输出tensor
        b = tf.constant(value=1, dtype=tf.float32)
        logits_eval = tf.multiply(logits, b, name='logits_eval')
        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=logits, labels=y_)
        train_op = tf.train.AdamOptimizer(learning_rate=0.0001).minimize(loss)
        correct_prediction = tf.equal(tf.cast(tf.argmax(logits, 1), tf.int32), y_)
        acc = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))
        # 训练和测试数据，可将n_epoch设置更大一些
        n_epoch = 10  # 1个epoch等于使用训练集中的全部样本训练一次
        batch_size = 16  # 批大小
        saver = tf.train.Saver()
        sess = tf.Session()
        sess.run(tf.global_variables_initializer())
        for epoch in range(n_epoch):
            start_time = time.time()
            # training
            train_loss, train_acc, n_batch = 0, 0, 0
            for x_train_a, y_train_a in self.minibatches(x_train, y_train, batch_size, shuffle=True):
                _, err, ac = sess.run([train_op, loss, acc], feed_dict={x: x_train_a, y_: y_train_a})
                train_loss += err
                train_acc += ac
                n_batch += 1
            print("train loss: %f" % (np.sum(train_loss) / n_batch))
            print("train acc: %f" % (np.sum(train_acc) / n_batch))
            # validation
            val_loss, val_acc, n_batch = 0, 0, 0
            for x_val_a, y_val_a in self.minibatches(x_val, y_val, batch_size, shuffle=False):
                err, ac = sess.run([loss, acc], feed_dict={x: x_val_a, y_: y_val_a})
                val_loss += err
                val_acc += ac
                n_batch += 1
            print("validation loss: %f" % (np.sum(val_loss) / n_batch))
            print("validation acc: %f" % (np.sum(val_acc) / n_batch))
        saver.save(sess, 'E:/model')
        sess.close()

    def read_img(self, path):
        '读取图片'
        cate = [path + x for x in os.listdir(path) if os.path.isdir(path + x)]
        imgs = []
        labels = []
        for idx, folder in enumerate(cate):
            for im in glob.glob(folder + '/*.png'):
                img = Image.open(im)
                if img.size != (256, 256):
                    img = img.resize((256, 256), Image.ANTIALIAS)
                imgs.append(np.asarray(img))
                labels.append(idx)
        return np.asarray(imgs, np.float), np.asarray(labels, np.int)

    def inference(self, input_tensor, train, regularizer, w, h):
        with tf.variable_scope('layer1-conv1'):
            conv1_weights = tf.get_variable("weight", [3, 3, 1, 32],
                                            initializer=tf.truncated_normal_initializer(stddev=0.1))
            conv1_biases = tf.get_variable("bias", [32], initializer=tf.constant_initializer(0.0))
            conv1 = tf.nn.conv2d(input_tensor, conv1_weights, strides=[1, 1, 1, 1], padding='SAME')
            relu1 = tf.nn.relu(tf.nn.bias_add(conv1, conv1_biases))

        with tf.name_scope("layer2-pool1"):
            pool1 = tf.nn.max_pool(relu1, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding="VALID")

        with tf.variable_scope("layer3-conv2"):
            conv2_weights = tf.get_variable("weight", [3, 3, 32, 64],
                                            initializer=tf.truncated_normal_initializer(stddev=0.1))
            conv2_biases = tf.get_variable("bias", [64], initializer=tf.constant_initializer(0.0))
            conv2 = tf.nn.conv2d(pool1, conv2_weights, strides=[1, 1, 1, 1], padding='SAME')
            relu2 = tf.nn.relu(tf.nn.bias_add(conv2, conv2_biases))

        with tf.name_scope("layer4-pool2"):
            pool2 = tf.nn.max_pool(relu2, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID')

        with tf.variable_scope("layer5-conv3"):
            conv3_weights = tf.get_variable("weight", [3, 3, 64, 128],
                                            initializer=tf.truncated_normal_initializer(stddev=0.1))
            conv3_biases = tf.get_variable("bias", [128], initializer=tf.constant_initializer(0.0))
            conv3 = tf.nn.conv2d(pool2, conv3_weights, strides=[1, 1, 1, 1], padding='SAME')
            relu3 = tf.nn.relu(tf.nn.bias_add(conv3, conv3_biases))

        with tf.name_scope("layer6-pool3"):
            pool3 = tf.nn.max_pool(relu3, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID')

        with tf.variable_scope("layer7-conv4"):
            conv4_weights = tf.get_variable("weight", [3, 3, 128, 256],
                                            initializer=tf.truncated_normal_initializer(stddev=0.1))
            conv4_biases = tf.get_variable("bias", [256], initializer=tf.constant_initializer(0.0))
            conv4 = tf.nn.conv2d(pool3, conv4_weights, strides=[1, 1, 1, 1], padding='SAME')
            relu4 = tf.nn.relu(tf.nn.bias_add(conv4, conv4_biases))

        with tf.name_scope("layer8-pool4"):
            pool4 = tf.nn.max_pool(relu4, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID')

        with tf.variable_scope("layer9-conv5"):
            conv5_weights = tf.get_variable("weight", [3, 3, 256, 256],
                                            initializer=tf.truncated_normal_initializer(stddev=0.1))
            conv5_biases = tf.get_variable("bias", [256], initializer=tf.constant_initializer(0.0))
            conv5 = tf.nn.conv2d(pool4, conv5_weights, strides=[1, 1, 1, 1], padding='SAME')
            relu5 = tf.nn.relu(tf.nn.bias_add(conv5, conv5_biases))

        with tf.name_scope("layer10-pool5"):
            pool5 = tf.nn.max_pool(relu5, ksize=[1, 2, 2, 1], strides=[1, 2, 2, 1], padding='VALID')
            # int(w/32)*int(h/32)
            nodes = int(w / 32) * int(h / 32) * 256
            reshaped = tf.reshape(pool5, [-1, nodes])

        with tf.variable_scope('layer11-fc1'):
            fc1_weights = tf.get_variable("weight", [nodes, 1024],
                                          initializer=tf.truncated_normal_initializer(stddev=0.1))
            if regularizer != None: tf.add_to_collection('losses', regularizer(fc1_weights))
            fc1_biases = tf.get_variable("bias", [1024], initializer=tf.constant_initializer(0.1))
            fc1 = tf.nn.relu(tf.matmul(reshaped, fc1_weights) + fc1_biases)
            #if train: fc1 = tf.nn.dropout(fc1, 0.25)

        with tf.variable_scope('layer12-fc2'):
            fc2_weights = tf.get_variable("weight", [1024, 512],
                                          initializer=tf.truncated_normal_initializer(stddev=0.1))
            if regularizer != None: tf.add_to_collection('losses', regularizer(fc2_weights))
            fc2_biases = tf.get_variable("bias", [512], initializer=tf.constant_initializer(0.1))

            fc2 = tf.nn.relu(tf.matmul(fc1, fc2_weights) + fc2_biases)
            #if train: fc2 = tf.nn.dropout(fc2, 0.25)

        with tf.variable_scope('layer13-fc3'):
            fc3_weights = tf.get_variable("weight", [512, 256],
                                          initializer=tf.truncated_normal_initializer(stddev=0.1))
            if regularizer != None: tf.add_to_collection('losses', regularizer(fc3_weights))
            fc3_biases = tf.get_variable("bias", [256], initializer=tf.constant_initializer(0.1))
            fc3 = tf.nn.relu(tf.matmul(fc2, fc3_weights) + fc3_biases)
            #if train: fc3 = tf.nn.dropout(fc3, 0.25)

        with tf.variable_scope('layer13-fc4'):
            fc4_weights = tf.get_variable("weight", [256, 2],
                                          initializer=tf.truncated_normal_initializer(stddev=0.1))
            if regularizer != None: tf.add_to_collection('losses', regularizer(fc4_weights))
            fc4_biases = tf.get_variable("bias", [2], initializer=tf.constant_initializer(0.1))
            logit = tf.matmul(fc3, fc4_weights) + fc4_biases

        return logit

    def minibatches(self, inputs=None, targets=None, batch_size=None, shuffle=False):
        '按批次取数据'
        assert len(inputs) == len(targets)
        if shuffle:
            indices = np.arange(len(inputs))
            np.random.shuffle(indices)
        for start_idx in range(0, len(inputs) - batch_size + 1, batch_size):
            if shuffle:
                excerpt = indices[start_idx:start_idx + batch_size]
            else:
                excerpt = slice(start_idx, start_idx + batch_size)
            yield inputs[excerpt], targets[excerpt]

    def CNN_predict(self, test_dir):
        filePaths = self.testfile2gray(test_dir)
        imgs = []
        for im in filePaths:
            #print(im)
            img = Image.open(im.split('.')[0] + '.png')
            if img.size != (256, 256):
                img = img.resize((256, 256), Image.ANTIALIAS)
            imgs.append(np.asarray(img))
        data = np.asarray(imgs,np.float)
        (dx, dy, dz) = data.shape
        data = data.reshape([dx, dy, dz, 1])
        code_dict = {0:'Malware', 1:'safe'}
        with tf.Session() as sess:
            saver = tf.train.import_meta_graph('E:/model.meta')
            saver.restore(sess, tf.train.latest_checkpoint('E:/'))
            graph = tf.get_default_graph()
            x = graph.get_tensor_by_name("x:0")
            feed_dict = {x: data}
            logits = graph.get_tensor_by_name("logits_eval:0")
            classification_result = sess.run(logits, feed_dict)
            # 打印出预测矩阵
            # print(classification_result)
            # 打印出预测矩阵每一行最大值的索引
            # print(tf.argmax(classification_result, 1).eval())
            # 根据索引通过字典对应花的分类
            output = tf.argmax(classification_result, 1).eval()
            i = 0
            j = 0
            result = ""
            for code_file in filePaths:
                # print("程序位于 " + code_file + ": " + code_dict[output[i]])
                if output[i] == 0:
                    result += code_file + ": " + code_dict[output[i]] + "\n"
                    j = j + 1
                i = i + 1
            print(j / i)
            return result

    def testfile2gray(self, file_dir):
        filePaths = []
        bytesCodeList = []
        imgPaths = []
        for x in os.listdir(file_dir):
            if '.png' not in x:
                img = file_dir + x.split('.')[0] + '.png'
                filePaths.append(file_dir + x)
                if os.path.exists(img) != True:
                    data = self.getCodeSeg(file_dir + x)
                    if data != None:
                        bytesCode = self.LZSS(data, 10, 20)
                        bytesCodeList.append(bytesCode)
                        imgPaths.append(img)
        i = 0
        for bytesCode in bytesCodeList:
            self.bytes2image(bytesCode, imgPaths[i], 256 * 256)
            i = i + 1
        return filePaths

    def file2gray(self, file_dir):
        cate = [file_dir + x for x in os.listdir(file_dir) if os.path.isdir(file_dir + x)]
        bytesCodeList = []
        imgPaths = []
        for idx, folder in enumerate(cate):
            for fi in glob.glob(folder + '/*'):
                #print('reading the file:%s' % (fi))
                filename = fi.split('\\')[-1].split('.')[0]
                img = folder + '\\' + filename + '.png'
                if os.path.exists(img) != True:
                    data = self.getCodeSeg(fi)
                    if data != None:
                        bytesCode = self.LZSS(data, 10, 20)
                        bytesCodeList.append(bytesCode)
                        imgPaths.append(img)
                # else:infected
        i = 0
        for bytesCode in bytesCodeList:
            self.bytes2image(bytesCode, imgPaths[i], 256 * 256)
            i = i + 1

    def getCodeSeg(self, PEfile_Path):
        pe = pefile.PE(PEfile_Path)
        for section in pe.sections:
            if bytes.decode(section.Name, 'UTF-8').find('.text') >= 0:
                miscVirtualSize = section.Misc_VirtualSize
                virtualAddr = section.VirtualAddress
                data = pe.get_data(virtualAddr, miscVirtualSize)
                return data

    def LZSS(self, message, buffer_size, dictionary_size):
        'LZSS压缩，输入窗口长度，编码信息，返回压缩后的元组'
        dictionary = ""
        buffer = message[:buffer_size]
        output = []
        while len(buffer) != 0:
            size, shift = self.find_in_dict(buffer, dictionary)
            if size == 0:
                output.append((0, 0, int.from_bytes(message[:1], byteorder='big')))
                size = 1
            else:
                output.append((1, shift, size))
            dictionary += str(int.from_bytes(message[:size], byteorder='big'))
            dictionary = dictionary[-dictionary_size:]
            message = message[size:]
            buffer = message[:buffer_size]
        return np.asarray(output)

    def find_in_dict(self, buffer, dictionary):
        shift = len(dictionary)
        substring = ""
        for character in buffer:
            substring_tmp = substring + str(character)
            shift_tmp = dictionary.rfind(substring_tmp)
            if shift_tmp < 0:
                break
            substring = substring_tmp
            shift = shift_tmp
        return len(substring), len(dictionary) - shift

    def bytes2image(self, bytesCode, img_path, maxsize):
        '输入代码段和图片地址，生成灰度图'
        # width = 256
        # height = 256
        size = bytesCode.size
        # if size < maxsize:
        #     pad = maxsize - size
        #     pad_value = np.zeros((pad, 1))
        #     bytesCode = bytesCode.reshape(size, 1)
        #     bytesCode = np.insert(bytesCode, -1, pad_value, 0)
        #     bytesCode = bytesCode.reshape(256, 256)
        # elif size > maxsize:
        width = int(math.sqrt(size))
        height = int(size / width) + 1
        maxsize = width * height
        pad = maxsize - size
        pad_value = np.zeros((pad, 1))
        bytesCode = bytesCode.reshape(size, 1)
        bytesCode = np.insert(bytesCode, -1, pad_value, 0)
        bytesCode = bytesCode.reshape(width, height)
        cv2.imwrite(img_path, np.uint8(bytesCode))


if __name__ == '__main__':
    app = wx.App()
    login = Main(parent=None)
    login.Show()
    app.MainLoop()
